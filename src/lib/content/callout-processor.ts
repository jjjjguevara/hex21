'use client';

/**
 * Client-side processor for callouts
 * Transforms callout DIVs generated by rehype-obsidian-callouts into styled callouts
 * Supports both light and dark themes
 */

// Type definitions for color schemes
interface ColorSet {
  bg: string;
  border: string;
  text: string;
  icon: string;
}

interface ThemeColorMap {
  light: Record<string, ColorSet>;
  dark: Record<string, ColorSet>;
}

/**
 * Process Obsidian callouts in the DOM
 * This transforms div elements with rt-CalloutRoot class into Radix UI callouts
 */
export function processCallouts(container: HTMLElement): void {
  if (!container) return;

  // Process both div.rt-CalloutRoot and blockquote[data-callout-type] elements
  processRadixCallouts(container);
  processBlockquoteCallouts(container);
  
  // Set up theme change observer
  setupThemeObserver();
}

/**
 * Process callouts in the Radix UI div format
 */
function processRadixCallouts(container: HTMLElement): void {
  // Find all callout containers with class rt-CalloutRoot
  const callouts = container.querySelectorAll('div.rt-CalloutRoot');
  
  // Process each callout
  callouts.forEach(callout => {
    if (!(callout instanceof HTMLElement)) return;
    
    // Extract accent color
    const accentColor = callout.getAttribute('data-accent-color') || 'gray';
    
    // Find icon element
    const iconElement = callout.querySelector('.rt-CalloutIcon');
    let iconContent = '';
    if (iconElement instanceof HTMLElement) {
      const iconSpan = iconElement.querySelector('span');
      if (iconSpan) {
        iconContent = iconSpan.textContent || '';
      }
    }
    
    // Find and extract text content
    const textElement = callout.querySelector('.rt-CalloutText');
    if (!(textElement instanceof HTMLElement)) return;
    
    // Apply Radix-like styling to the callout
    const isDark = detectDarkMode(); // Detect theme
    applyCalloutStyling(callout, accentColor, accentColor, isDark);
  });
}

/**
 * Process callouts in the blockquote format with proper HTML structure
 */
function processBlockquoteCallouts(container: HTMLElement): void {
  // Find all blockquote elements with data-callout-type attribute
  const callouts = container.querySelectorAll('blockquote[data-callout-type]');
  const isDark = detectDarkMode(); // Detect theme once for all callouts

  callouts.forEach(callout => {
    // Skip if already processed
    if (callout.classList.contains('processed-callout')) {
      return;
    }
    callout.classList.add('processed-callout');

    if (!(callout instanceof HTMLElement)) return;

    const calloutType = callout.getAttribute('data-callout-type') || 'note';
    const calloutTitle = callout.getAttribute('data-callout-title') || '';
    const accentColor = mapTypeToColor(calloutType);

    // Save original content
    const originalContent = document.createDocumentFragment();
    while (callout.firstChild) {
      originalContent.appendChild(callout.firstChild);
    }

    // --- Create new structure ---
    callout.innerHTML = ''; // Clear existing content
    callout.style.display = 'flex';
    callout.style.padding = '12px'; // Reduced padding
    callout.style.borderRadius = '6px';
    callout.style.gap = '8px'; // Reduced gap
    callout.style.margin = '20px 0'; // Keep vertical margin
    callout.style.alignItems = 'flex-start'; // Align icon and text top

    // 1. Icon Column
    const iconContainer = document.createElement('div');
    iconContainer.className = 'callout-icon';
    iconContainer.style.flexShrink = '0';
    // iconContainer.style.marginRight = '8px'; // Gap handles spacing now
    callout.appendChild(iconContainer);

    // 2. Content Column
    const contentContainer = document.createElement('div');
    contentContainer.className = 'callout-content';
    contentContainer.style.flex = '1'; // Allow content to take remaining space
    callout.appendChild(contentContainer);

    // --- Populate Icon --- 
    const iconName = calloutIconMap[calloutType] || 'Info';
    console.log(`[DEBUG] Processing callout type '${calloutType}', using icon name: '${iconName}'`); // Log icon name
    // Get the icon data (IconNode = [string, Attrs, IconNode[]?])
    const iconNodeData = icons[iconName];
    console.log(`[DEBUG] Raw iconNodeData for '${iconName}':`, JSON.stringify(iconNodeData)); // Log raw data

    if (iconNodeData) {
      const svgElement = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
      // IconNode is [tagName, attributes, children]
      const [tagName, attrs = {}, iconChildren = []] = iconNodeData; // Assuming structure [tag, attrs, children?]

      // Set common SVG attributes from the main icon node
      Object.entries(attrs).forEach(([key, value]) => {
        // Only apply standard SVG attributes to the <svg> tag itself
        if (['width', 'height', 'viewBox', 'fill', 'stroke', 'stroke-width', 'stroke-linecap', 'stroke-linejoin'].includes(key)) {
           svgElement.setAttribute(key, String(value));
        }
      });

      // Add default attributes if missing - Adjusted to common Lucide defaults
      if (!svgElement.getAttribute('width')) svgElement.setAttribute('width', '16'); // Smaller default
      if (!svgElement.getAttribute('height')) svgElement.setAttribute('height', '16'); // Smaller default
      if (!svgElement.getAttribute('viewBox')) svgElement.setAttribute('viewBox', '0 0 24 24');
      if (!svgElement.getAttribute('fill')) svgElement.setAttribute('fill', 'none');
      if (!svgElement.getAttribute('stroke')) svgElement.setAttribute('stroke', 'currentColor');
      if (!svgElement.getAttribute('stroke-width')) svgElement.setAttribute('stroke-width', '2');
      if (!svgElement.getAttribute('stroke-linecap')) svgElement.setAttribute('stroke-linecap', 'round');
      if (!svgElement.getAttribute('stroke-linejoin')) svgElement.setAttribute('stroke-linejoin', 'round');

      // Render the actual icon elements (paths, circles, etc.)
      const innerSvgHtml = renderLucideChildren(iconNodeData);
      svgElement.innerHTML = innerSvgHtml;
      console.log(`[DEBUG] Generated inner SVG HTML for '${iconName}':`, innerSvgHtml); // Log inner HTML

      // Append the complete SVG to the icon container
      iconContainer.appendChild(svgElement);
      console.log(`[DEBUG] Final SVG Element outerHTML for '${iconName}':`, svgElement.outerHTML); // Log final SVG
    } else {
      console.error(`[DEBUG] Icon node data not found for icon name: '${iconName}'`); // Log if icon data is missing
      iconContainer.textContent = '?'; // Fallback
    }

    // --- Populate Content --- 
    // Add Title if present
    if (calloutTitle) {
      const titleElement = document.createElement('strong');
      titleElement.textContent = calloutTitle;
      titleElement.style.display = 'block';
      titleElement.style.marginBottom = '5px'; // Space below title
      contentContainer.appendChild(titleElement);
    }

    // Add original content (paragraphs, lists, etc.)
    contentContainer.appendChild(originalContent);

    // --- Apply Styling --- 
    applyCalloutStyling(callout, calloutType, accentColor, isDark);
  });
}

/**
 * Map callout type to color
 */
function mapTypeToColor(calloutType: string): string {
  switch (calloutType.toLowerCase()) {
    case 'note':
      return 'blue';
    case 'abstract':
      return 'gray';
    case 'info':
      return 'cyan';
    case 'todo':
      return 'violet';
    case 'tip':
      return 'green';
    case 'success':
      return 'green';
    case 'question':
      return 'purple';
    case 'warning':
      return 'amber';
    case 'failure':
      return 'red';
    case 'danger':
      return 'red';
    case 'bug':
      return 'red';
    case 'example':
      return 'teal';
    case 'quote':
      return 'gray';
    case 'disclaimer':
      return 'crimson';
    default:
      return 'blue';
  }
}

/**
 * Detect if dark mode is active
 */
function detectDarkMode(): boolean {
  if (typeof window !== 'undefined') {
    // Check for stored preference first
    const storedPreference = localStorage.getItem('theme');
    if (storedPreference === 'dark') return true;
    if (storedPreference === 'light') return false;

    // Fallback to system preference
    return window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
  }
  return false; // Default to light mode on server or if window is undefined
}

/**
 * Set up observer to detect theme changes
 */
function setupThemeObserver(): void {
  if (typeof window === 'undefined' || typeof MutationObserver === 'undefined') {
    return;
  }

  const htmlElement = document.documentElement;
  const bodyElement = document.body;

  const themeObserver = new MutationObserver(() => {
    // Re-apply styling to all processed callouts when theme changes
    const callouts = document.querySelectorAll('.processed-callout');
    callouts.forEach(callout => {
      if (callout instanceof HTMLElement) {
        // Retrieve necessary info from the existing callout element
        const calloutType = callout.getAttribute('data-callout-type') || 'note';
        const accentColor = mapTypeToColor(calloutType);
        const contentElement = callout.querySelector('.callout-content') as HTMLElement;
        
        // Only re-apply styling if we found the content element
        if (contentElement) {
            // Re-apply styling with the updated theme colors
            applyCalloutStyling(callout, calloutType, accentColor, detectDarkMode()); // Pass a flag to indicate style-only update
        }
      }
    });
  });

  const observerConfig = { attributes: true, attributeFilter: ['class', 'data-theme', 'style'] }; // Added 'style' just in case theme is applied via inline style

  if (htmlElement) themeObserver.observe(htmlElement, observerConfig);
  if (bodyElement) themeObserver.observe(bodyElement, observerConfig);
}

/**
 * Apply callout styling directly to HTML elements
 * This avoids requiring Radix UI components on the client-side
 */
function applyCalloutStyling(
  callout: HTMLElement,
  type: string,
  colorName: string,
  isDark: boolean
): void {
  // Define theme-aware color mappings
  const themeColorMap: ThemeColorMap = {
    light: { // Subtler light theme colors
      blue: { bg: '#F0F9FF', border: '#E0F2FE', text: '#075985', icon: '#2196F3' },
      red: { bg: '#FEF2F2', border: '#FEE2E2', text: '#B91C1C', icon: '#DC2626' },
      green: { bg: '#F0FDF4', border: '#DCFCE7', text: '#15803D', icon: '#16A34A' },
      yellow: { bg: '#FFFBEB', border: '#FEF3C7', text: '#B45309', icon: '#D97706' },
      purple: { bg: '#FAF5FF', border: '#F3E8FF', text: '#7E22CE', icon: '#9333EA' },
      gray: { bg: '#F8FAFC', border: '#F1F5F9', text: '#475569', icon: '#64748B' },
      amber: { bg: '#FFFBEB', border: '#FEF3C7', text: '#B45309', icon: '#D97706' },
      indigo: { bg: '#EEF2FF', border: '#E0E7FF', text: '#3730A3', icon: '#6366F1' },
      violet: { bg: '#F5F3FF', border: '#EDE9FE', text: '#7A3BD9', icon: '#8B5CF6' },
      teal: { bg: '#F0FDFA', border: '#CCFBF1', text: '#115E59', icon: '#2DD4BF' },
      cyan: { bg: '#ECFEFF', border: '#CFFAFE', text: '#0E7490', icon: '#06B6D4' },
      crimson: { bg: '#FFF1F2', border: '#FFE4E6', text: '#9D174D', icon: '#F87171' }
    },
    dark: { // Existing dark theme colors
      blue: { bg: '#172554', border: '#1E3A8A', text: '#BFDBFE', icon: '#93C5FD' },
      purple: { bg: '#3B0764', border: '#581C87', text: '#E9D5FF', icon: '#D8B4FE' },
      red: { bg: '#450A0A', border: '#7F1D1D', text: '#FECACA', icon: '#FCA5A5' },
      yellow: { bg: '#422006', border: '#78350F', text: '#FEF08A', icon: '#FDE047' },
      green: { bg: '#052E16', border: '#065F46', text: '#BBF7D0', icon: '#86EFAC' },
      cyan: { bg: '#083344', border: '#164E63', text: '#A5F3FC', icon: '#67E8F9' },
      gray: { bg: '#1F2937', border: '#374151', text: '#D1D5DB', icon: '#9CA3AF' },
    },
  };

  // Determine the current theme's color set
  const currentThemeColors = isDark ? themeColorMap.dark : themeColorMap.light;
  const colorSet = currentThemeColors[colorName] || currentThemeColors.gray; // Fallback to gray

  // Apply styles
  callout.style.backgroundColor = colorSet.bg;
  callout.style.borderLeft = `4px solid ${colorSet.border}`;
  callout.style.color = colorSet.text;

  // Apply icon color
  const iconSvg = callout.querySelector('.callout-svg-icon') as SVGElement | null;
  if (iconSvg) {
    iconSvg.style.stroke = colorSet.icon || colorSet.text; // Use specific icon color or fallback to text color
  }
}

// Define the mapping from callout types to Lucide icon names
const calloutIconMap: { [key: string]: keyof typeof icons } = {
  note: 'FileText',
  abstract: 'ScrollText',
  info: 'Info',
  tip: 'Lightbulb',
  success: 'CheckCircle',
  question: 'HelpCircle',
  warning: 'TriangleAlert',
  failure: 'XOctagon',
  danger: 'Skull',
  bug: 'Bug',
  example: 'FlaskConical',
  quote: 'Quote',
  // Add other types as needed
};

// Import Lucide icons
import { icons } from 'lucide';

// Function to render Lucide icon children (like path, circle) to SVG elements
function renderLucideChildren(children: any[]): string {
  let html = '';
  console.log("[DEBUG] renderLucideChildren input:", JSON.stringify(children)); // Keep input log

  if (!Array.isArray(children)) {
    console.error("[DEBUG] renderLucideChildren expected an array, got:", typeof children);
    return ''; // Return empty if input is not an array
  }

  for (const child of children) {
    // Each child should be [tagName, attributes]
    if (!Array.isArray(child) || child.length !== 2) {
      console.error("[DEBUG] Invalid child format. Expected [tag, attrs], got:", JSON.stringify(child));
      continue; // Skip this child
    }

    const [tag, attrs] = child;

    // Validate tag and attrs types
    if (typeof tag !== "string" || typeof attrs !== "object" || attrs === null) {
      console.error(`[DEBUG] Invalid tag or attrs type. Tag: ${tag} (${typeof tag}), Attrs: ${JSON.stringify(attrs)} (${typeof attrs})`);
      continue; // Skip this child
    }

    // Convert attributes object to string "key='value'"
    try {
      const attrsString = Object.entries(attrs)
        .map(([key, value]) => `${key}="${value}"`) // Ensure value is properly stringified if needed
        .join(' ');
      const generatedTag = `<${tag} ${attrsString} />`;
      html += generatedTag;
    } catch (e) {
      console.error(`[DEBUG] Error processing attributes for tag ${tag}:`, e, 'Attrs:', JSON.stringify(attrs));
    }
  }

  console.log("[DEBUG] renderLucideChildren final output HTML:", html); // Keep final output log
  return html;
}

// Export the main function if needed by other modules
export function initializeCallouts(): void {
  if (typeof document === 'undefined') return; // Guard for server-side rendering

  // Initial processing might depend on when this script runs
  // Ensure DOM is ready if called early
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => processCallouts(document.body));
  } else {
    processCallouts(document.body);
  }
  
  // Set up observer for theme changes
  setupThemeObserver();
}

// Consider calling initializeCallouts() from appropriate client-side entry point
// For testing purposes, call it here:
// initializeCallouts(); // Let MarkdownContent call it
