/**
 * Processes embedded content within markdown
 * Handles embedding of content from other files and images
 */

import path from 'path'; // Keep for extension checking

// List of supported image extensions
const IMAGE_EXTENSIONS = ['.png', '.jpg', '.jpeg', '.gif', '.svg', '.webp', '.avif'];

/**
 * Processes Obsidian-style embeds within a container element.
 * This version looks for placeholder spans generated server-side.
 */
export function processEmbeds(container: HTMLElement, assetBasePath: string = '/content/assets') {
  // console.log('[Embed Processor] Called with assetBasePath:', assetBasePath);

  // Find placeholder spans generated by the remark plugin
  const placeholders = container.querySelectorAll<HTMLElement>('span[data-type="embed"]');
  // console.log(`[Embed Processor] Found ${placeholders.length} placeholder spans.`);

  placeholders.forEach(span => {
    const source = span.dataset.source;
    const altText = span.dataset.alt;
    const size = span.dataset.size;

    // --- DEBUG LOG ---
    // console.log(`[Embed Processor] Processing placeholder: source="${source}", alt="${altText}", size="${size}"`);
    // --- END DEBUG LOG ---

    if (!source) {
      console.warn('[Embed Processor] Skipping placeholder span with no data-source:', span);
      return; // Skip if source is missing
    }

    let replacementElement: HTMLElement;
    const extension = path.extname(source).toLowerCase();
    const isImage = IMAGE_EXTENSIONS.includes(extension);

    if (isImage) {
      const imgElement = document.createElement('img');
      imgElement.src = `${assetBasePath}/${source}`;
      imgElement.alt = altText || path.basename(source, extension); // Use alt or derive from filename
      imgElement.loading = 'lazy';
      imgElement.decoding = 'async';
      imgElement.dataset.embed = source; // Keep original source if needed

      // Apply size attributes if present
      if (size) {
        // Simple numeric size (e.g., "100") - assume width
        if (/^\d+$/.test(size)) {
          imgElement.width = parseInt(size, 10);
        } 
        // Specific width/height (e.g., "width=100" or "height=50%")
        else if (/^(width|height)=(\d+%?)$/.test(size)) {
           const match = size.match(/^(width|height)=(\d+%?)$/);
           if (match && match[1] && match[2]) {
             if (match[1] === 'width') {
               imgElement.style.width = isNaN(parseInt(match[2])) ? match[2] : `${match[2]}px`;
             } else {
               imgElement.style.height = isNaN(parseInt(match[2])) ? match[2] : `${match[2]}px`;
             }
           }
        } 
        // Width x Height (e.g., "100x50")
        else if (/^(\d+)x(\d+)$/.test(size)) {
          const dimensions = size.split('x');
          imgElement.width = parseInt(dimensions[0], 10);
          imgElement.height = parseInt(dimensions[1], 10);
        }
      }
      replacementElement = imgElement;
      // console.log(`[Embed Processor] Created image element:`, imgElement);

    } else {
      // Handle non-image embeds (e.g., create a link or placeholder div)
      const placeholderDiv = document.createElement('div');
      placeholderDiv.classList.add('embed-placeholder');
      placeholderDiv.dataset.source = source;
      if (altText) placeholderDiv.dataset.title = altText;
      placeholderDiv.textContent = `Embed: ${source}`; // Simple text representation
      replacementElement = placeholderDiv;
      // console.log(`[Embed Processor] Created non-image placeholder:`, placeholderDiv);
    }

    // Replace the placeholder span with the created element
    if (span.parentNode) {
      span.parentNode.replaceChild(replacementElement, span);
    } else {
      console.warn('[Embed Processor] Placeholder span has no parent node:', span);
    }
  });
}