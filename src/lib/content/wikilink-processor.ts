/**
 * Processes Obsidian-style wikilinks within a given container element.
 * This version looks for placeholder spans generated server-side.
 */
export function processWikilinks(container: HTMLElement, basePath: string = '') {
  console.log('[Wikilink Processor] Called with basePath:', basePath);

  // Find placeholder spans generated by the remark plugin
  const placeholders = container.querySelectorAll<HTMLElement>('span[data-type="wikilink"]');
  console.log(`[Wikilink Processor] Found ${placeholders.length} placeholder spans.`);

  placeholders.forEach(span => {
    const target = span.dataset.target;
    const alias = span.dataset.alias;

    // --- DEBUG LOG --- 
    console.log(`[Wikilink Processor] Processing placeholder: target="${target}", alias="${alias}"`);
    // --- END DEBUG LOG ---

    if (!target) {
      console.warn('[Wikilink Processor] Skipping placeholder span with no data-target:', span);
      return; // Skip if target is missing
    }

    let linkElement: HTMLAnchorElement;

    // Check if target is an external URL
    if (/^https?:\/\//i.test(target)) {
      linkElement = document.createElement('a');
      linkElement.setAttribute('href', target); // Explicitly set href attribute
      linkElement.innerText = alias || target;  // Use innerText instead of textContent
      linkElement.target = '_blank'; // Open external links in a new tab
      linkElement.rel = 'noopener noreferrer'; // Security measure
      linkElement.classList.add('external-link'); // Optional: class for styling
      console.log(`[Wikilink Processor] Created external link:`, linkElement);
    } else {
      // Handle as internal wikilink
      linkElement = document.createElement('a');
      linkElement.classList.add('wiki-link');
      linkElement.setAttribute('data-target', target); // Keep original target in data-
      if (alias) linkElement.setAttribute('data-alias', alias);
      linkElement.textContent = alias || target; // Display alias or target
      processWikilinkElement(linkElement, basePath); // Process internal link (adds href etc.)
      console.log(`[Wikilink Processor] Created internal link:`, linkElement);
    }

    // Replace the placeholder span with the created link element
    if (span.parentNode) {
      span.parentNode.replaceChild(linkElement, span);
    } else {
      console.warn('[Wikilink Processor] Placeholder span has no parent node:', span);
    }
  });
}

/**
 * Helper function to process a single wikilink anchor element.
 * Determines the correct href based on the target and basePath.
 */
function processWikilinkElement(link: HTMLAnchorElement, basePath: string) {
  const target = link.dataset.target;
  const alias = link.dataset.alias;

  if (!target) {
    console.warn('Wikilink element is missing data-target:', link);
    return;
  }

  // Basic slugification (replace spaces with hyphens, lowercase, remove invalid chars)
  // Ensure consistent slug generation matching server-side if possible
  const slug = target
    .replace(/\.md$/i, '') // Remove .md extension if present
    .replace(/\s+/g, '-')
    .toLowerCase()
    .replace(/[^a-z0-9-_/]/g, ''); // Allow slashes for nested paths

  // Construct the final URL with proper path handling
  // Normalize the path handling to ensure no double slashes
  let href = '';
  
  if (basePath) {
    // If basePath exists, join with the slug
    href = `/${basePath}/${slug}`;
  } else {
    // If no basePath, just use the slug
    href = `/${slug}`;
  }
  
  // Clean up any double slashes except for the protocol
  href = href.replace(/([^:])\/{2,}/g, '$1/');
  
  // Add logging for debugging
  console.log(`[Wikilink Processor] Created href: ${href} from basePath: ${basePath} and slug: ${slug}`);

  link.href = href;

  // Ensure text content is set (using alias or target)
  if (!link.textContent) {
    link.textContent = alias || target;
  }
}